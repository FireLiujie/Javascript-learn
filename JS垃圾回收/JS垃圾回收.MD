V8 垃圾回收机制
JavaScript 具有自动垃圾收集机制（GC:GarbageCollecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理

内存生命周期
JS 环境中分配的内存一般有如下生命周期：
1、内存分配：当我们申明变量、函数、对象并执行的时候，系统会自动为他们分配内存
2、内存使用：即读写内存，也就是使用变量、函数等
3、内存回收：使用完毕，由垃圾回执机制自动回收不再使用的内存

垃圾回收机制策略
标记清除算法
JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”

该算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始（在 JS 中就是全局对象）扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段（sweep）。
1、标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象
2、清除阶段，垃圾回收期会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作

在标记阶段，从根对象 1 可以访问到 B，从 B 又可以访问到 E，那么 B 和 E 都是可到达对象，同样的道理，F、G、J 和 K 都是可到达对象

在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收

何时开始垃圾回收？
通常来说，在使用标记清除算法时，未引用对象并不会立即回收。取而代之的做法是，垃圾对象将一直累积到内存耗尽为止。当内存耗尽时，程序将会被挂起，垃圾回收开始执行

补充：从 2012 年起，所有现代浏览器都是用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

标记清除算法缺陷
1、那些无法从根对象查询到的对象都将被清除
2、垃圾收集后有可能会造成大量的内存碎片，想上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表 1 个单位的内存，如果有一个对象需要占用 3 个内存单位的话，那么就会导致 Mutator 一直处于暂停状态，而 Collector 一直在尝试进行垃圾收集，直到 Out of Memory。

引用计数算法

这是最初的垃圾收集算法，现在已经没有浏览器会用这种算法

此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1.当这个值的引用次数变 0 时，则说明没有办法再访问这个值，因而就可以将其占用的内从空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存

引用计数缺陷

该算法有个限制：无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用技术算法考虑到它们互相都至少一次引用，所有它们不会被回收

Chrome V8 垃圾回收算法

chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。这个和 Java 回收策略思想是一致的，目的是通过区分[临时]与[持久]对象；多回收[临时对象区]（新生代 younggeneration），少回收[持久对象区]（老生代 tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时

V8 的内存限制
在 node 中 javascript 能使用的内存是有限制
1、64 位系统下约为 1.4GB
2、32 位系统下约为 0.7GB
对应到分代内存中，默认情况下。
1、32 位系统新生代内存大小为 16MB，老生代内存大小为 700MB
2、64 位系统下，新生代内存大小为 32MB，老生代内存大小为 1.4GB

新生代平均分成两块相等的内存空间，叫做 semispace，每块内存大小 8MB（32 位）或 16MB（64 位）
这个限制在 node 启动的时候可以通过传递--max-old-space-size 和--max-new-space-size 来调整，如：
node --max-old-space-size=1700 app.js // 单位为 MB
node --max-new-space-size=1024 app.js // 单位为 kb

上述参数在 V8 初始化时生效，一旦生效就不能再动态改变

内存限制的原因：
至于 V8 为何要限制堆的大小，表层原因：V8 最初为浏览器而设计，不太可能遇到用大量内存的场景。深层原因：V8 的垃圾回收机制的限制。官方说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JS 线程暂停执行的时间，在这样的花销下，应用的性能和响应能力都会直线下降。

V8 的分代回收（Generation GC）
V8 垃圾回收策略主要基于分代式垃圾回收机制。现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

V8 的内存分代：

在 V8 中，主要讲内存分为新生代和老生代，新生代内存 存储的未存活时间较短的对象，老生代内存 存储的为存活时间较长或常驻内存的对象，如下图：

V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。
