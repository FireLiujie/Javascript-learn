### 首先，我们应该实例化一个 Mvue 对象，其中应该包括挂载点(el)和数据(data)

### 需要注意的是，我们的 Mvue 应该包含在作用域挂载点 el 对应的节点内

### 编写思路

1、通过 el 挂载点找到对应的元素，获取该元素下所有的子元素

2、通过 nodeType 来判断子元素是节点还是文本（1 为节点、3 为文本）

3、当 nodeType 为 3 时，通过正则表达式/\{\{\s*(\S+)\s*\}\}/g 来判断是否为插值表达式，如果是则取该正则匹配到的第一个子表达式的结果，这里需要注意的是，插值表达式可能并不在第一个节点中，因此，我们需要进行递归来判断所有子节点

4、通过 textContent 将 data 中的值替换过来

5、我们需要把 data 进行数据劫持，劫持方法可以使用 Object.defineProperty(obj,key,{})

6、使用发布-订阅模式，首先，编写发布者类 Dep 和订阅者类 Watcher，我们在初始化编译的时候实例化一个订阅者 new Watcher()，但是我们需要把该订阅者的实例化对象注册到发布者 Dep 的实例化对象中去，我们可以在 Watcher 的 constructor 函数中添加一个 Dep.target 标识符指向我们的实例化的订阅者

7、我们在数据劫持的时候，在 get()中把该订阅者注册到发布者实例中去，这里有一个问题，get()是需要对象获取该属性才能执行该 get()函数中的逻辑，所以我们在 new Watcher 时，将该属性初始化进 Watcher 的实例中,然后我们再清空 Dep.target，因为此时该订阅者已经注册

8、在变更数据时，在 set()中，发布者通知订阅者数据已经变更，我们可以把变更的数据一直传到订阅者的 update 函数中去

9、这里有一个问题，我们不需要在 update 中写那么多的逻辑，发布-订阅模式只是通知已经变更，具体怎么变更，逻辑还是在变更的地方去写，因此我们可以写一个回调函数来解决这个问题，在 update 函数中调用该回调函数

10、在初始化订阅者 Watcher 的回调函数中写视图更新

### v-model 编写思路

1、在 nodeType 为 1 时，获取该节点下的所有属性

2、遍历所有的属性，当属性中有"m-"开头时，说明找到了我们自定义属性

3、当属性名为 model 时，当前节点的 value 值可以根据属性对应的 value 值找到

4、当变更 input 中的内容时，使用 addEventListener 监听函数来监听变更的内容，将该内容赋值给上述属性对应的 value 值对应的值

5、当直接变更 data 中的值时，input 中的内容并没有变更，这是因为我们并没有注册 watcher，此时，我们 new Watcher，将 input 中的 value 等于传入的 newValue 即可

### 以上方案的问题

1、并未实现 data 数据的多层嵌套

2、如果插值表达式后面仍有其他的文本，则该文本在变更的时候会消失

3、该方案并未实现性能的最优化
